// ModuleInterfaceMacro.swift - Module interface macro implementation
// Copyright Â© 2025 SwinjectUtilityMacros. All rights reserved.

import SwiftCompilerPlugin
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import Swinject

/// Implementation of the @ModuleInterface macro
/// Marks protocols that can be used across module boundaries
public struct ModuleInterfaceMacro: ExtensionMacro {

    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {

        // Ensure it's applied to a protocol
        guard let protocolDecl = declaration.as(ProtocolDeclSyntax.self) else {
            throw DiagnosticsError(diagnostics: [
                Diagnostic(
                    node: declaration,
                    message: ModuleInterfaceDiagnostic.requiresProtocol
                )
            ])
        }

        let protocolName = protocolDecl.name.text

        // Generate a unique identifier for cross-module resolution
        let extensionCode = """
        extension \(protocolName) {
            /// Unique identifier for cross-module resolution
            public static var moduleInterfaceIdentifier: String {
                "\\(String(reflecting: Self.self))"
            }
        }
        """

        let extensionDecl = DeclSyntax(stringLiteral: extensionCode)

        return [extensionDecl]
    }
}

/// Implementation of the @Provides macro
public struct ProvidesMacro: PeerMacro {

    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {

        // Ensure it's applied to a static function
        guard let functionDecl = declaration.as(FunctionDeclSyntax.self),
              functionDecl.modifiers.contains(where: { $0.name.text == "static" })
        else {
            throw DiagnosticsError(diagnostics: [
                Diagnostic(
                    node: declaration,
                    message: ProvidesDiagnostic.requiresStaticFunction
                )
            ])
        }

        // Parse arguments
        let arguments = node.arguments?.as(LabeledExprListSyntax.self) ?? []
        let scope = extractScope(from: arguments)
        let name = extractString(from: arguments, label: "name")
        let implements = extractType(from: arguments, label: "implements")

        let functionName = functionDecl.name.text
        let returnType = functionDecl.signature.returnClause?.type

        guard let returnType = returnType else {
            throw DiagnosticsError(diagnostics: [
                Diagnostic(
                    node: functionDecl,
                    message: ProvidesDiagnostic.requiresReturnType
                )
            ])
        }

        // Generate registration code
        let registrationType = implements ?? returnType.description
        let registrationName = name != nil ? ", name: \"\(name!)\"" : ""

        let registrationCode = """
        // Registration generated by @Provides
        private static let _register_\(functionName): Void = {
            ModuleSystem.shared.rootContainer.register(\(registrationType).self\(registrationName)) { _ in
                \(functionName)()
            }.inObjectScope(.container)
        }()
        """

        return [DeclSyntax(stringLiteral: registrationCode)]
    }

    private static func extractScope(from arguments: LabeledExprListSyntax) -> ObjectScope {
        for argument in arguments {
            if argument.label?.text == "scope" {
                if let memberAccess = argument.expression.as(MemberAccessExprSyntax.self) {
                    switch memberAccess.declName.baseName.text {
                    case "singleton":
                        return .container
                    case "transient":
                        return .transient
                    case "weak":
                        return .weak
                    default:
                        return .graph
                    }
                }
            }
        }
        return .graph
    }

    private static func extractString(from arguments: LabeledExprListSyntax, label: String) -> String? {
        for argument in arguments {
            if argument.label?.text == label {
                if let stringLiteral = argument.expression.as(StringLiteralExprSyntax.self),
                   let segment = stringLiteral.segments.first?.as(StringSegmentSyntax.self)
                {
                    return segment.content.text
                }
            }
        }
        return nil
    }

    private static func extractType(from arguments: LabeledExprListSyntax, label: String) -> String? {
        for argument in arguments {
            if argument.label?.text == label {
                if let memberAccess = argument.expression.as(MemberAccessExprSyntax.self),
                   let base = memberAccess.base
                {
                    return base.description
                }
            }
        }
        return nil
    }
}

/// Implementation of the @Include macro
public struct IncludeMacro: PeerMacro {

    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {

        // Parse arguments to get module type and condition
        guard let arguments = node.arguments?.as(LabeledExprListSyntax.self),
              let firstArg = arguments.first
        else {
            throw DiagnosticsError(diagnostics: [
                Diagnostic(
                    node: node,
                    message: IncludeDiagnostic.requiresModuleType
                )
            ])
        }

        let moduleType: String
        if let memberAccess = firstArg.expression.as(MemberAccessExprSyntax.self),
           let base = memberAccess.base
        {
            moduleType = base.description
        } else {
            throw DiagnosticsError(diagnostics: [
                Diagnostic(
                    node: node,
                    message: IncludeDiagnostic.invalidModuleType
                )
            ])
        }

        // Generate inclusion code
        let inclusionCode = """
        // Module inclusion generated by @Include
        private static let _include_\(moduleType): Void = {
            \(moduleType).register(in: ModuleSystem.shared)
        }()
        """

        return [DeclSyntax(stringLiteral: inclusionCode)]
    }
}

// MARK: - Object Scope Extension

// TODO: Fix ObjectScope integration
// extension ObjectScope {
//     var scopeMethod: String {
//         switch self {
//         case .transient:
//             "inObjectScope(.transient)"
//         case .container:
//             "inObjectScope(.container)"
//         case .weak:
//             "inObjectScope(.weak)"
//         default:
//             "inObjectScope(.graph)"
//         }
//     }
// }

// MARK: - Diagnostics

enum ModuleInterfaceDiagnostic: String, DiagnosticMessage {
    case requiresProtocol = "@ModuleInterface can only be applied to protocols"

    var message: String { rawValue }
    var diagnosticID: MessageID {
        MessageID(domain: "SwinjectUtilityMacros", id: rawValue)
    }

    var severity: DiagnosticSeverity { .error }
}

enum ProvidesDiagnostic: String, DiagnosticMessage {
    case requiresStaticFunction = "@Provides can only be applied to static functions"
    case requiresReturnType = "@Provides requires a function with a return type"

    var message: String { rawValue }
    var diagnosticID: MessageID {
        MessageID(domain: "SwinjectUtilityMacros", id: rawValue)
    }

    var severity: DiagnosticSeverity { .error }
}

enum IncludeDiagnostic: String, DiagnosticMessage {
    case requiresModuleType = "@Include requires a module type argument"
    case invalidModuleType = "Invalid module type provided to @Include"

    var message: String { rawValue }
    var diagnosticID: MessageID {
        MessageID(domain: "SwinjectUtilityMacros", id: rawValue)
    }

    var severity: DiagnosticSeverity { .error }
}
