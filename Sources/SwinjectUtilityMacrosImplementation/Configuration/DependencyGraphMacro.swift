// DependencyGraphMacro.swift - Implementation of @DependencyGraph macro

import SwiftSyntax
import SwiftSyntaxMacros
import SwiftSyntaxBuilder

/// Implementation of the @DependencyGraph macro that generates dependency graph visualization
public struct DependencyGraphMacro: MemberMacro, ExtensionMacro {
    
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        // Parse macro arguments
        let arguments = parseArguments(from: node)
        
        return [
            DeclSyntax("""
            // MARK: - Dependency Graph Methods (Generated by @DependencyGraph)
            
            func generateDependencyGraph(format: GraphFormat = .\(raw: arguments.format.rawValue)) -> String {
                // Generate dependency graph in specified format
                let nodes: [DependencyNode] = []
                let edges: [DependencyEdge] = []
                
                switch format {
                case .graphviz:
                    return DependencyGraphGenerator.generateDotGraph(nodes: nodes, edges: edges)
                case .json:
                    return DependencyGraphGenerator.generateJSONGraph(nodes: nodes, edges: edges)
                case .mermaid:
                    return DependencyGraphGenerator.generateMermaidGraph(nodes: nodes, edges: edges)
                default:
                    return DependencyGraphGenerator.generateDotGraph(nodes: nodes, edges: edges)
                }
            }
            
            func detectCircularDependencies() -> [CircularDependencyInfo] {
                // Detect circular dependencies in the graph
                let graph = DependencyGraph(nodes: [], edges: [], circularDependencies: [])
                return CircularDependencyDetector.detectCircularDependencies(in: graph)
            }
            
            func exportDependencyGraph(to path: String, format: GraphFormat = .\(raw: arguments.format.rawValue)) throws {
                // Export dependency graph to file
                let content = generateDependencyGraph(format: format)
                try content.write(to: URL(fileURLWithPath: path), atomically: true, encoding: .utf8)
            }
            
            func getDependencyAnalysis() -> DependencyAnalysisReport {
                // Generate comprehensive dependency analysis
                return DependencyAnalysisReport(
                    totalServices: 0,
                    totalDependencies: 0,
                    circularDependencies: detectCircularDependencies(),
                    orphanedServices: [],
                    highlyDependentServices: [],
                    dependencyDepth: [:]
                )
            }
            """)
        ]
    }
    
    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        
        let extensionDecl = try ExtensionDeclSyntax("""
        extension \(type.trimmed): DependencyGraphProvider {
            // Generated conformance to DependencyGraphProvider
        }
        """)
        
        return [extensionDecl]
    }
    
    // MARK: - Argument Parsing
    
    private static func parseArguments(from attribute: AttributeSyntax) -> DependencyGraphArguments {
        var format: GraphFormat = .graphviz
        var includeOptional = true
        var detectCycles = true
        var exportPath: String? = nil
        var realTimeUpdates = false
        var strictCycleDetection = true
        var breakCyclesAutomatically = false
        
        guard case let .argumentList(arguments) = attribute.arguments else {
            return DependencyGraphArguments(
                format: format,
                includeOptional: includeOptional,
                detectCycles: detectCycles,
                exportPath: exportPath,
                realTimeUpdates: realTimeUpdates,
                strictCycleDetection: strictCycleDetection,
                breakCyclesAutomatically: breakCyclesAutomatically
            )
        }
        
        for argument in arguments {
            guard let label = argument.label?.text else { continue }
            
            switch label {
            case "format":
                if let memberAccess = argument.expression.as(MemberAccessExprSyntax.self) {
                    let formatName = memberAccess.declName.baseName.text
                    format = GraphFormat(rawValue: formatName) ?? .graphviz
                }
            case "includeOptional":
                includeOptional = argument.expression.as(BooleanLiteralExprSyntax.self)?.literal.text == "true"
            case "detectCycles":
                detectCycles = argument.expression.as(BooleanLiteralExprSyntax.self)?.literal.text == "true"
            case "exportPath":
                if let stringLiteral = argument.expression.as(StringLiteralExprSyntax.self) {
                    exportPath = stringLiteral.segments.first?.as(StringSegmentSyntax.self)?.content.text
                }
            case "realTimeUpdates":
                realTimeUpdates = argument.expression.as(BooleanLiteralExprSyntax.self)?.literal.text == "true"
            case "strictCycleDetection":
                strictCycleDetection = argument.expression.as(BooleanLiteralExprSyntax.self)?.literal.text == "true"
            case "breakCyclesAutomatically":
                breakCyclesAutomatically = argument.expression.as(BooleanLiteralExprSyntax.self)?.literal.text == "true"
            default:
                break
            }
        }
        
        return DependencyGraphArguments(
            format: format,
            includeOptional: includeOptional,
            detectCycles: detectCycles,
            exportPath: exportPath,
            realTimeUpdates: realTimeUpdates,
            strictCycleDetection: strictCycleDetection,
            breakCyclesAutomatically: breakCyclesAutomatically
        )
    }
}

// MARK: - Supporting Types

private struct DependencyGraphArguments {
    let format: GraphFormat
    let includeOptional: Bool
    let detectCycles: Bool
    let exportPath: String?
    let realTimeUpdates: Bool
    let strictCycleDetection: Bool
    let breakCyclesAutomatically: Bool
}

private enum GraphFormat: String {
    case graphviz = "graphviz"
    case json = "json"
    case mermaid = "mermaid"
    case xml = "xml"
    case yaml = "yaml"
}